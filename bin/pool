#!/usr/bin/env bash
set -euo pipefail

# pool - Fast worktree management with pre-seeded pool
#
# This script provides instant worktree creation by maintaining a pool of
# pre-created worktrees that can be claimed and renamed on demand.
#
# Usage:
#   pool <branch-name>              Create/switch to worktree for branch
#   pool init [--bare <url>]        Initialize pool (or convert to bare repo)
#   pool status                     Show pool and worktree status
#   pool refill                     Refill the worktree pool
#   pool clean [type]               Clean up worktrees
#   pool help                       Show detailed help
#
# Examples:
#   pool feature-xyz                Switch to feature-xyz branch instantly
#   pool init                       Initialize pool in current repo
#   pool init --bare git@github...  Clone as bare repo with pool
#   pool clean merged               Remove worktrees for merged branches
#
# Environment:
#   WORKTREE_POOL_SIZE             Number of pre-seeded worktrees (default: 5)

# Configuration
POOL_SIZE=${WORKTREE_POOL_SIZE:-5}
POOL_PREFIX="pool-"
CONFIG_FILE=".worktree-pool"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
confirm() {
    read -p "$1 [y/N] " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]]
}

show_help() {
    cat <<'EOF'
pool - Fast worktree management with pre-seeded pool

USAGE:
    pool <branch-name>              Create/switch to worktree for branch
    pool init [options]             Initialize worktree pool
    pool status                     Show pool and worktree status
    pool refill                     Refill the worktree pool
    pool clean [type]               Clean up worktrees
    pool help                       Show this help message

INIT OPTIONS:
    pool init                       Initialize pool in current repository
    pool init --convert             Convert current repo to bare with worktrees
    pool init --bare <url>          Clone repository as bare with pool
    pool init --pool-size N         Set pool size (default: 5)

CLEAN TYPES:
    pool clean orphaned             Remove orphaned worktrees (safe)
    pool clean stale                Remove worktrees for deleted branches
    pool clean merged               Remove worktrees for merged branches
    pool clean pool                 Reset pool worktrees to clean state
    pool clean all                  Run all cleanup tasks
    pool clean --dry-run [type]     Preview what would be cleaned

WORKFLOW:
    1. Initialize: pool init
    2. Work on feature: pool feature-xyz
    3. Switch branches: pool another-feature
    4. Check status: pool status
    5. Clean up: pool clean merged

CONVERTING TO BARE REPO:
    If you have an existing repository and want to convert it to a bare
    repository with worktrees (recommended for large repos):

    $ pool init --convert

    This will:
    - Create a bare clone of your repository
    - Set up the main worktree
    - Initialize the worktree pool
    - Provide instructions for completing the conversion

ENVIRONMENT VARIABLES:
    WORKTREE_POOL_SIZE    Number of pre-seeded worktrees (default: 5)

EXAMPLES:
    # Initialize pool in current repo
    $ pool init

    # Start working on a new feature
    $ pool feature-authentication

    # Clone a repo as bare with pool
    $ pool init --bare git@github.com:user/repo.git

    # Check pool status
    $ pool status

    # Clean up merged branches
    $ pool clean merged

    # Preview all cleanup actions
    $ pool clean --dry-run all
EOF
}

# Check if we're in a git repository (unless initializing bare)
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi
    return 0
}

# Get repository info
get_repo_info() {
    GIT_DIR=$(git rev-parse --git-dir)
    GIT_COMMON_DIR=$(git rev-parse --git-common-dir)
    REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || dirname "$GIT_COMMON_DIR")
    DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
}

# Initialize worktree pool
init_pool() {
    local pool_size=${1:-$POOL_SIZE}

    log_info "Initializing worktree pool with $pool_size worktrees..."

    # Create pool directory
    mkdir -p "$REPO_ROOT/.worktree-pool"

    # Initialize pool
    for i in $(seq 1 "$pool_size"); do
        pool_name="${POOL_PREFIX}${i}"
        pool_path="$REPO_ROOT/.worktree-pool/$pool_name"

        if [ ! -d "$pool_path" ]; then
            log_info "Creating pool worktree $i/$pool_size..."
            git worktree add -q "$pool_path" -b "$pool_name" "$DEFAULT_BRANCH"
            echo "available" >"$pool_path/.pool-status"
        fi
    done

    log_success "Worktree pool initialized with $pool_size worktrees"
}

# Convert existing repo to bare
convert_to_bare() {
    if ! check_git_repo; then
        log_error "Not in a git repository"
        return 1
    fi

    get_repo_info

    # Check if already bare
    if git rev-parse --is-bare-repository 2>/dev/null | grep -q true; then
        log_error "Repository is already bare"
        return 1
    fi

    # Check if in a worktree
    if [ "$GIT_COMMON_DIR" != "$GIT_DIR" ]; then
        log_error "Cannot convert from within a worktree. Please run from the main repository."
        return 1
    fi

    REPO_NAME=$(basename "$REPO_ROOT")
    PARENT_DIR=$(dirname "$REPO_ROOT")
    CURRENT_BRANCH=$(git branch --show-current)

    log_info "Converting $REPO_NAME to bare repository with worktrees..."

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        log_error "You have uncommitted changes. Please commit or stash them first."
        return 1
    fi

    # Create temporary bare clone
    cd "$PARENT_DIR"
    BARE_DIR="${REPO_NAME}.git"

    if [ -d "$BARE_DIR" ]; then
        log_error "Directory $BARE_DIR already exists"
        return 1
    fi

    log_info "Creating bare repository..."
    git clone --bare "$REPO_ROOT" "$BARE_DIR"

    # Set up fetch refs for all branches
    cd "$BARE_DIR"
    git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'

    # Create main worktree with same name as original
    log_info "Creating main worktree..."
    git worktree add "../${REPO_NAME}-main" "$CURRENT_BRANCH"

    # Initialize worktree pool
    get_repo_info
    init_pool

    # Copy pool script if available
    if [ -f "$REPO_ROOT/bin/pool" ]; then
        cp "$REPO_ROOT/bin/pool" pool
        chmod +x pool
    fi

    log_success "Conversion complete!"
    echo ""
    log_info "Next steps:"
    echo "  1. Verify everything works in: $PARENT_DIR/${REPO_NAME}-main"
    echo "  2. Remove old repository: rm -rf $REPO_ROOT"
    echo "  3. Rename directories:"
    echo "     mv $PARENT_DIR/$BARE_DIR $PARENT_DIR/$REPO_NAME"
    echo "     mv $PARENT_DIR/${REPO_NAME}-main $PARENT_DIR/$REPO_NAME/main"
    echo "  4. Use: cd $PARENT_DIR/$REPO_NAME && ./pool <branch-name>"
}

# Clone as bare repository
clone_bare() {
    local repo_url=$1
    local pool_size=${2:-$POOL_SIZE}

    REPO_NAME=$(basename "$repo_url" .git)

    log_info "Cloning $repo_url as bare repository..."

    # Clone bare
    git clone --bare "$repo_url" "$REPO_NAME"
    cd "$REPO_NAME"

    # Set up fetch refs for all branches
    git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
    git fetch origin

    # Determine default branch
    DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    # Create main worktree
    log_info "Creating main worktree..."
    git worktree add "main" "$DEFAULT_BRANCH"

    # Initialize worktree pool
    get_repo_info
    init_pool "$pool_size"

    # Copy pool script if available
    if [ -f "$HOME/dev/dotfiles/bin/pool" ]; then
        cp "$HOME/dev/dotfiles/bin/pool" pool
        chmod +x pool
    fi

    log_success "Setup complete!"
    echo ""
    log_info "Usage: cd $REPO_NAME && ./pool <branch-name>"
}

# Show pool status
show_status() {
    log_info "Worktree pool status:"
    echo ""

    # Check pool worktrees
    pool_count=0
    available_count=0

    if [ -d "$REPO_ROOT/.worktree-pool" ]; then
        for pool_dir in "$REPO_ROOT/.worktree-pool"/${POOL_PREFIX}*; do
            if [ -d "$pool_dir" ]; then
                pool_count=$((pool_count + 1))
                pool_name=$(basename "$pool_dir")

                if [ -f "$pool_dir/.pool-status" ] && [ "$(cat "$pool_dir/.pool-status")" = "available" ]; then
                    echo -e "  ${GREEN}●${NC} $pool_name - available"
                    available_count=$((available_count + 1))
                else
                    echo -e "  ${RED}●${NC} $pool_name - in use"
                fi
            fi
        done
    fi

    echo ""
    echo "Pool size: $pool_count"
    echo "Available: $available_count"
    echo ""

    # Show active worktrees
    log_info "Active worktrees:"
    git worktree list | grep -v "\.worktree-pool" | grep -v "(bare)" || true
}

# Refill pool
refill_pool() {
    log_info "Refilling worktree pool..."

    # Create missing pool worktrees
    for i in $(seq 1 "$POOL_SIZE"); do
        pool_name="${POOL_PREFIX}${i}"
        pool_path="$REPO_ROOT/.worktree-pool/$pool_name"

        if [ ! -d "$pool_path" ]; then
            log_info "Creating pool worktree $pool_name..."
            git worktree add -q "$pool_path" -b "$pool_name" "$DEFAULT_BRANCH"
            echo "available" >"$pool_path/.pool-status"
        fi
    done

    log_success "Pool refilled"
}

# Clean orphaned worktrees
clean_orphaned() {
    log_info "Cleaning orphaned worktrees..."

    if [ "${DRY_RUN:-false}" = true ]; then
        git worktree list --porcelain | grep -B2 "prunable" || echo "No orphaned worktrees found"
    else
        git worktree prune
        log_success "Orphaned worktrees cleaned"
    fi
}

# Clean stale branches
clean_stale() {
    log_info "Finding stale branches in worktrees..."

    while IFS= read -r line; do
        if [[ $line =~ ^worktree[[:space:]](.+) ]]; then
            worktree_path="${BASH_REMATCH[1]}"

            # Skip pool worktrees
            if [[ "$worktree_path" =~ \.worktree-pool ]]; then
                continue
            fi

            # Get branch info
            branch_line=$(git worktree list --porcelain | grep -A2 "^worktree $worktree_path" | grep "^branch")
            if [[ $branch_line =~ ^branch[[:space:]]refs/heads/(.+) ]]; then
                branch="${BASH_REMATCH[1]}"

                # Check if branch exists on remote
                if ! git ls-remote --heads origin "$branch" | grep -q "$branch"; then
                    log_warning "Branch '$branch' not found on remote (worktree: $worktree_path)"

                    if [ "${DRY_RUN:-false}" = false ] && confirm "Remove worktree for deleted branch '$branch'?"; then
                        git worktree remove "$worktree_path"
                        log_success "Removed worktree: $worktree_path"
                    fi
                fi
            fi
        fi
    done < <(git worktree list --porcelain)
}

# Reset pool worktrees
clean_pool() {
    log_info "Resetting pool worktrees..."

    if [ ! -d "$REPO_ROOT/.worktree-pool" ]; then
        log_warning "No worktree pool found"
        return
    fi

    for pool_dir in "$REPO_ROOT/.worktree-pool"/${POOL_PREFIX}*; do
        if [ -d "$pool_dir" ]; then
            pool_name=$(basename "$pool_dir")

            # Check if marked as available but has changes
            if [ -f "$pool_dir/.pool-status" ] && [ "$(cat "$pool_dir/.pool-status")" = "available" ]; then
                cd "$pool_dir"

                # Check for uncommitted changes
                if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                    log_warning "Pool worktree $pool_name has uncommitted changes"

                    if [ "${DRY_RUN:-false}" = false ] && confirm "Reset pool worktree $pool_name?"; then
                        git reset --hard
                        git clean -fd
                        git checkout "$pool_name"
                        log_success "Reset pool worktree: $pool_name"
                    fi
                fi

                cd "$REPO_ROOT"
            fi
        fi
    done
}

# Remove worktrees for merged branches
clean_merged() {
    log_info "Finding worktrees with merged branches..."

    # Update remote branches
    git fetch origin --prune

    # Get merged branches
    merged_branches=$(git branch -r --merged "origin/$DEFAULT_BRANCH" | grep -v "$DEFAULT_BRANCH" | sed 's/origin\///')

    while IFS= read -r line; do
        if [[ $line =~ ^worktree[[:space:]](.+) ]]; then
            worktree_path="${BASH_REMATCH[1]}"

            # Skip pool worktrees and bare repo
            if [[ "$worktree_path" =~ \.worktree-pool ]] || [[ "$worktree_path" =~ \(bare\) ]]; then
                continue
            fi

            # Get branch info
            branch_line=$(git worktree list --porcelain | grep -A2 "^worktree $worktree_path" | grep "^branch")
            if [[ $branch_line =~ ^branch[[:space:]]refs/heads/(.+) ]]; then
                branch="${BASH_REMATCH[1]}"

                # Check if branch is merged
                if echo "$merged_branches" | grep -q "^$branch$"; then
                    log_warning "Branch '$branch' has been merged (worktree: $worktree_path)"

                    if [ "${DRY_RUN:-false}" = false ] && confirm "Remove worktree for merged branch '$branch'?"; then
                        git worktree remove "$worktree_path"
                        git branch -d "$branch" 2>/dev/null || true
                        log_success "Removed worktree and branch: $branch"
                    fi
                fi
            fi
        fi
    done < <(git worktree list --porcelain)
}

# Create or switch to worktree
create_worktree() {
    local branch_name=$1
    local worktree_path="$REPO_ROOT/${branch_name//\//-}"

    log_info "Setting up worktree for branch: $branch_name"

    # Find an available worktree from the pool
    POOL_WORKTREE=""
    if [ -d "$REPO_ROOT/.worktree-pool" ]; then
        for pool_dir in "$REPO_ROOT/.worktree-pool"/${POOL_PREFIX}*; do
            if [ -d "$pool_dir" ] && [ -f "$pool_dir/.pool-status" ]; then
                if [ "$(cat "$pool_dir/.pool-status")" = "available" ]; then
                    POOL_WORKTREE="$pool_dir"
                    break
                fi
            fi
        done
    fi

    if [ -z "$POOL_WORKTREE" ]; then
        log_warning "No available worktrees in pool. Creating new worktree..."

        # Check if worktree already exists
        if git worktree list | grep -q "$worktree_path"; then
            log_warning "Worktree already exists at $worktree_path"
            cd "$worktree_path"
            code .
            return
        fi

        # Check if branch exists remotely
        if git ls-remote --heads origin "$branch_name" | grep -q "$branch_name"; then
            log_info "Branch exists remotely, checking out..."
            git worktree add "$worktree_path" -b "$branch_name" "origin/$branch_name"
        else
            log_info "Creating new branch..."
            git worktree add "$worktree_path" -b "$branch_name" "$DEFAULT_BRANCH"
        fi
    else
        # Use pool worktree
        log_info "Using pool worktree: $(basename "$POOL_WORKTREE")"

        # Mark as in use
        echo "in-use" >"$POOL_WORKTREE/.pool-status"

        # Check if target already exists
        if [ -d "$worktree_path" ]; then
            log_warning "Directory already exists at $worktree_path"
            echo "available" >"$POOL_WORKTREE/.pool-status"
            cd "$worktree_path"
            code .
            return
        fi

        # Update git worktree path
        cd "$POOL_WORKTREE"

        # Fetch latest changes
        git fetch origin

        # Check if branch exists
        if git ls-remote --heads origin "$branch_name" | grep -q "$branch_name"; then
            log_info "Checking out existing branch..."
            git checkout -B "$branch_name" "origin/$branch_name"
        else
            log_info "Creating new branch..."
            git checkout -B "$branch_name" "$DEFAULT_BRANCH"
        fi

        # Move the worktree directory
        cd "$REPO_ROOT"
        git worktree move "$POOL_WORKTREE" "$worktree_path"

        # Update git's worktree registry
        git worktree repair

        # Refill pool in background
        (
            sleep 2
            pool_name=$(basename "$POOL_WORKTREE")
            new_pool_path="$REPO_ROOT/.worktree-pool/$pool_name"
            if [ ! -d "$new_pool_path" ]; then
                git worktree add -q "$new_pool_path" -b "$pool_name" "$DEFAULT_BRANCH" 2>/dev/null
                echo "available" >"$new_pool_path/.pool-status"
            fi
        ) &
    fi

    # Open in VS Code
    log_success "Opening $worktree_path in VS Code..."
    cd "$worktree_path"
    code .

    # Show status
    echo ""
    log_info "Worktree ready at: $worktree_path"
    log_info "Branch: $branch_name"
}

# Main command handling
case "${1:-}" in
help | --help | -h)
    show_help
    ;;

init)
    shift
    if [ "${1:-}" = "--convert" ]; then
        convert_to_bare
    elif [ "${1:-}" = "--bare" ] && [ -n "${2:-}" ]; then
        pool_size=$POOL_SIZE
        if [ "${3:-}" = "--pool-size" ] && [ -n "${4:-}" ]; then
            pool_size=$4
        fi
        clone_bare "$2" "$pool_size"
    else
        if ! check_git_repo; then
            log_error "Not in a git repository"
            exit 1
        fi
        get_repo_info

        # Check if already in a worktree
        if [ "$GIT_COMMON_DIR" != "$GIT_DIR" ]; then
            log_error "Cannot initialize pool from within a worktree. Please run from the main repository."
            exit 1
        fi

        pool_size=$POOL_SIZE
        if [ "${1:-}" = "--pool-size" ] && [ -n "${2:-}" ]; then
            pool_size=$2
        fi

        init_pool "$pool_size"
    fi
    ;;

status)
    if ! check_git_repo; then
        log_error "Not in a git repository"
        exit 1
    fi
    get_repo_info
    show_status
    ;;

refill)
    if ! check_git_repo; then
        log_error "Not in a git repository"
        exit 1
    fi
    get_repo_info
    refill_pool
    ;;

clean)
    if ! check_git_repo; then
        log_error "Not in a git repository"
        exit 1
    fi
    get_repo_info

    shift
    DRY_RUN=false
    CLEAN_TYPE=""

    # Parse clean arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            CLEAN_TYPE="$1"
            shift
            ;;
        esac
    done

    case "$CLEAN_TYPE" in
    orphaned)
        clean_orphaned
        ;;
    stale)
        clean_stale
        ;;
    pool)
        clean_pool
        ;;
    merged)
        clean_merged
        ;;
    all)
        log_info "Running all cleanup tasks..."
        clean_orphaned
        echo ""
        clean_stale
        echo ""
        clean_pool
        echo ""
        clean_merged
        log_success "All cleanup tasks completed"
        ;;
    *)
        log_error "Unknown clean type: $CLEAN_TYPE"
        echo "Valid types: orphaned, stale, pool, merged, all"
        exit 1
        ;;
    esac

    if [ "$DRY_RUN" = true ]; then
        echo ""
        log_warning "This was a dry run. No changes were made."
    fi
    ;;

"")
    log_error "No command provided"
    echo "Usage: pool <branch-name> or pool help"
    exit 1
    ;;

*)
    # Assume it's a branch name
    if ! check_git_repo; then
        log_error "Not in a git repository"
        exit 1
    fi
    get_repo_info
    create_worktree "$1"
    ;;
esac
